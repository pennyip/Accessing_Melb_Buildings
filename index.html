<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accessing Melbourne's Buildings</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet">
  <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.0/mapbox-gl-geocoder.css" rel="stylesheet">
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.0/mapbox-gl-geocoder.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Varela&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Varela&display=swap');

#map {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100%;
}

/* grey bar on the left which everything will sit in */
#sidebar {
  position: fixed;
  right: 0;
  top: 0;
  bottom: 0;
  width: 210px;
  background-color: darkgrey;
  color: white;
  padding: 15px;
  z-index: 1;
  overflow-y: auto;
  overflow: visible;
  transition: transform 0.3s ease;
}

#sidebar.collapsed {
  transform: translateX(240px);
}

#toggle-sidebar {
  position: fixed;
  top: 12px;
  /* Center vertically */
  right: 225px;
  transform: translate(-50%, -50%);
  background-color: darkgrey;
  color: white;
  border: none;
  padding: 5px 10px;
  cursor: pointer;
  z-index: 2;
  transition: left 0.3s ease;
}

#toggle-sidebar::before {
  content: ">";
}

#toggle-sidebar.collapsed {
  right: 0;
}

#toggle-sidebar.collapsed::before {
  content: "<";
}

/* Sidebar content styles */
.sidebar-content {
  margin-top: 10px;
}

.sidebar-heading {
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 15px;
  text-align: center;
  font-family: "Montserrat", sans-serif;
}

.sidebar-text {
  font-size: 11px;
  margin-bottom: 10px;
  font-family: "Montserrat", sans-serif;
}

.credits {
  font-size: 10px;
  margin-bottom: 10px;
  font-family: "Montserrat", sans-serif;
}

.divider {
  height: 1px;
  background-color: white;
  margin: 10px 0;
}

.mapboxgl-popup {
  max-width: 200px;
  background-color: none;
  opacity: 0.8;
  font-family: "Montserrat", sans-serif;
}

.popup-content {
  font-family: "Montserrat", sans-serif;
  font-size: 14px;
  padding: 10px;
  background-color: #696969;
  border-radius: 5px;
  box-shadow: 10px rgba(0, 0, 0, 0.1);
  opacity: 0.7;
}

.popup-title {
  font-weight: bold;
  margin-bottom: 5px;
  font-family: "Montserrat", sans-serif;
}

.popup-description {
  margin-bottom: 0;
  font-family: "Montserrat", sans-serif;
}

/* Adjust the button container to allow for a grid layout */
#button {
  display: grid;
  grid-template-columns: 1fr 1fr; /* Two columns */
  gap: 10px; /* Space between buttons */
  background: none;
  border-radius: 3px;
  width: 100%;
  font-family: 'Varela', sans-serif;
}

/* Adjust individual button styles */
#button a {
  font-size: 11px;
  color: #404040;
  padding: 10px;
  text-decoration: none;
  text-align: center;
  background-color: #5e5e5e;
  border-radius: 5px;
}

#button a:hover {
  background-color: #f8f8f8;
  color: #404040;
}

#button a.active {
  background-color: #894b77;
  color: white;
  font-weight: normal;
}

#button a.active:hover {
  color: #f8f8f8;
}

#legend-buttons h4 {
  font-family: 'Varela', sans-serif;
  text-align: center;
  margin-bottom: 2px;
}

a.legend-button {
  font-size: 11px;
  color: white; /* White text color */
  display: block;
  margin: 5px;
  padding: 10px;
  text-decoration: none;
  text-align: left;
  background-color: #5e5e5e;
  border-radius: 5px;
  font-family: 'Varela', sans-serif;
}

/* Hover effect for inactive buttons */
a.legend-button:hover {
  background-color: #d3d3d3; 
  color: white; 
}

/* Specific colors for active buttons */
a#ratingnone.active {
  background-color: #d3d3d3;
}

a#rating0.active {
  background-color: #a8eec7;
}

a#rating1.active {
  background-color: #6dbab9;
}

a#rating2.active {
  background-color: #5481a0;
}

a#rating3.active {
  background-color: #413d66;
}

a.legend-button.active:hover {
  background-color: #c0c0c0 !important; 
  color: white !important; 
}

.public-transport {
  font-family: 'Varela', sans-serif;
  text-align: center;
  margin-bottom: 2px;
}

.heading-with-info {
  display: flex;
  text-align: center;
  justify-content: center;
  /* Center the container */
  align-items: center;
}

.heading-with-info h5 {
  margin: 0;
  font-family: "Montserrat", sans-serif;
  margin-right: 8px;
  /* space between text and button */
  font-size: 10px;
  text-align: center;
  font-weight: normal;
}

.info-button {
  position: relative;
  text-align: center;
  width: 12px;
  height: 12px;
  background-color: #5e5e5e;
  border-radius: 50%;
  color: white;
  font-size: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 10;
}

.info-button::after {
  content: 'The accessibility rating is an official rating used by the City of Melbourne and can be found on the "Building Information" open dataset. The levels are determined by certain variables such as steps, ramps and alternative entries.';
  font-family: "Montserrat", sans-serif;
  position: absolute;
  top: 100%;
  left: -100px;
  transform: translateX(-50%);
  width: 180px;
  background-color: #5e5e5e;
  color: white;
  font-size: 12px;
  line-height: 1.4;
  border-radius: 5px;
  padding: 10px;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
  z-index: 20;
}

.info-button:hover::after {
  opacity: 1;
  visibility: visible;
  z-index: 3;
}

.closest-distance-popup .mapboxgl-popup-content {
  background-color: #06402b;
  /* Change this to your desired color */
  color: white;
  /* Adjust the text color for readability */
}

#toggle-2d-3d {
  position: absolute;
  font-family: "Montserrat", sans-serif;
  top: 100px;
  left: 10px;
  background-color: #fff;
  border: none;
  padding: 8px 6px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1000;
  font-weight: bold;
  color: black;
  transition: background-color 0.3s ease;
}

#toggle-2d-3d:hover {
  background-color: #e0e0e0;
}

/* Button Styles */
.button {
  background-color: gray;
  color: white;
  border: none;
  padding: 7px 10px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 10px;
  cursor: pointer;
  border-radius: 5px;
  transition: background-color 0.3s ease;
}

/* Button Hover Effect */
.button:hover {
  background-color: lightgray;
}

/* Button Active Effect */
.button:active {
  background-color: darkgray;
}

.mapboxgl-ctrl-geocoder {
  max-width: 400px;
  max-height: 100px;
 font-family: "Montserrat", sans-serif;
 font-size: 10px;
  position: absolute;
  opacity: 90%;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10000;
  display: flex;
  align-items: center;
  background-color: white;
  border-radius: 5px;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
  padding: 5px;
}

.offstreet-heading {
  font-family: 'Varela', sans-serif;
  text-align: center;
  margin-bottom: 2px;
}

#parking-bars {
  display: flex;
  justify-content: space-around;
  align-items: flex-end;
  margin: 10px 0;
}

.bar-button {
  background-color: #656565;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin: 0 2px;
  outline: none;
  padding: 0;
}

.bar-button:hover {
  background-color: #242424;
}

.bar-button:active {
  background-color: #d6d6d6 !important;
}

.bar-button.active {
  background-color: #d6d6d6;
}

.bar-button.active:hover {
  background-color: #242424;
}

.bar-text {
  margin-top: 4px;
  font-size: 9px;
  color: #656565;
   font-family: "Montserrat", sans-serif;
}
        
</style>
</head>
<body>
<div id="sidebar">
  <div class="sidebar-content">
    <div class="sidebar-heading">Accessing Melbourne's Buildings</div>
    <div class="divider"></div>
    <div class="sidebar-text">Use this map to explore the level of accessibility of buildings in the City of Melbourne.
      <p></p>Click on the hexbins or building points to learn the off-street parking options, or click anywhere on the map to determine the nearest public transport options.
    <p></p>Searching an address in the search bar will further assist with route planning and choosing the most suitable transport option.</div>
      <div class="divider"></div>
    <nav id="legend-buttons">
      <h4>Legend</h4>
      <div class="heading-with-info">
        <h5>Building Accessibility Rating</h5>
        <div id="legend-info" class="info-button">i</div>
      </div>
      <!-- buttons to toggle building-points and hexbin layers -->
      <a href="#" class="legend-button" id="ratingnone">Undefined</a>
      <a href="#" class="legend-button" id="rating0">0 - Considered not accessible</a>
      <a href="#" class="legend-button" id="rating1">1 - Low level of accessibility</a>
      <a href="#" class="legend-button" id="rating2">2 - Moderate level of accessibility</a>
      <a href="#" class="legend-button" id="rating3">3 - High level of accessibility</a>
    </nav>
    <div class="divider"></div>
    <div class='public-transport'>Transport Options</div>
    <nav id="button">
      <!-- buttons to toggle public transport layers -->
      <a href="#" class="button" id="taxi-ranks">Taxi Ranks</a>
      <a href="#" class="button" id="train-stations">Train Stations</a>
      <a href="#" class="button" id="bus-stops">Bus Stops</a>
      <a href='#' class="button" id="tram-stops">Tram Stops</a>
    </nav>
    <div class="divider"></div>
      <div class="offstreet-heading">Number of Off-Street Car Spaces</div>
<div id="parking-bars">
  <div class="bar-container">
    <button id="barbutton1" class="bar-button active" style="height: 10px; width: 15px;" data-min="0" data-max="100"></button>
    <span class="bar-text">&lt;100</span>
  </div>
  <div class="bar-container">
    <button id="barbutton2" class="bar-button active" style="height: 20px; width: 15px;" data-min="101" data-max="200"></button>
    <span class="bar-text">&lt;200</span>
  </div>
  <div class="bar-container">
    <button id="barbutton3" class="bar-button active" style="height: 30px; width: 15px;" data-min="201" data-max="500"></button>
    <span class="bar-text">&lt;500</span>
  </div>
  <div class="bar-container">
    <button id="barbutton4" class="bar-button active" style="height: 40px; width: 15px;" data-min="501" data-max="1000"></button>
    <span class="bar-text">&lt;1000</span>
  </div>
  <div class="bar-container">
    <button id="barbutton5" class="bar-button active" style="height: 50px; width: 15px;" data-min="1001" data-max="3000"></button>
    <span class="bar-text">&lt;3000</span>
  </div>
  <div class="bar-container">
    <button id="barbutton6" class="bar-button active" style="height: 60px; width: 15px;" data-min="3001" data-max="6000"></button>
    <span class="bar-text"> &lt;6000</span>
  </div>
</div>
    <div class="divider"></div>
    <div class="credits"> Credit: Penny Prangnell (s4016698) <br>
      Source Data: City of Melbourne, 'Building Information', 'Off-street car parks with capacity and type', 'Taxi Ranks', 'Bus Stops' and 'Metro Train Stations with Accessibility Information', 2023.</div>
  </div>
</div>
<button id="toggle-sidebar"></button>
<button id="toggle-2d-3d">Switch View</button>
<div id='map'></div>
<div id="your-searchbar-container"></div>
<script>
//my mapbox unique access code
mapboxgl.accessToken = 'pk.eyJ1IjoiczQwMTY2OTgiLCJhIjoiY2x0b3lyMDcyMGtzcTJrcGFlN3ZzNnRtZyJ9.oc1p4S7lER0OXK8G6q1w8Q';

var bounds = [
  [144.838858, -37.870314],
  [145.094719, -37.766712]
];

var map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/s4016698/clvx9dv6h014i01rde4y6a4fo',
  maxBounds: bounds,
  zoom: 12.5,
  center: [144.956310, -37.827197],
  bearing: 35.20,
  pitch: 56.50
});

var accessNames = ['0', '1', '2', '3'];
var circleColors = ['#a8eec7', '#6dbab9', '#5481a0', '#413D66'];

fetch('https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/off_street_final.geojson')
  .then(response => response.json())
  .then(data => {
    map.on('load', function() {
    
// Variables to store GeoJSON data for the sources
let taxiRanksData, busStopsData, trainStationsData, tramStopsData;

// Fetch and store the data for each layer: taxi ranks, bus stops, train station.
fetch('https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/taxi-ranks.geojson')
  .then(response => response.json())
  .then(data => {
    taxiRanksData = data;
  });
  
fetch('https://raw.githubusercontent.com/pennyip/Accessing_Melb_Buildings/main/PTV_METRO_TRAM_FeaturesToJSO.geojson')
  .then(response => response.json())
  .then(data => {
    tramStopsData = data;
  });  

fetch('https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/bus-stops.geojson')
  .then(response => response.json())
  .then(data => {
    busStopsData = data;
  });

fetch('https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/metro-train-stations-with-accessibility-information.geojson')
  .then(response => response.json())
  .then(data => {
    trainStationsData = data;
  });
    

      var geocoder = new MapboxGeocoder({
  accessToken: mapboxgl.accessToken,
  mapboxgl: mapboxgl,
  placeholder: 'Search for an address',
  bbox: [144.838858, -37.870314, 145.094719, -37.766712],
  proximity: {
    longitude: 144.956310,
    latitude: -37.827197
  },
  marker: {
    color: '#de0f17', // Custom color for the marker
    scale: 0.8, // Scale to increase size
    opacity: 0.8,
  }
});


      document.getElementById('your-searchbar-container').appendChild(geocoder.onAdd(map));

      geocoder.on('result', function(e) {
        map.flyTo({
          center: e.result.geometry.coordinates,
          zoom: 14
        });
      });

      var bbox = turf.bbox(data);
      var cellSize = 0.08;

      var hexGrid = turf.hexGrid(bbox, cellSize, {
  units: 'kilometers'
});

hexGrid.features = hexGrid.features.map(hex => {
  var pointsWithin = turf.pointsWithinPolygon(data, hex).features;
  var parkingSpacesByRating = {
    '0': 0,
    '1': 0,
    '2': 0,
    '3': 0,
    'undefined': 0 // Add a category for undefined ratings
  };

  if (pointsWithin.length > 0) {
    pointsWithin.forEach(point => {
      var rating = point.properties['buildings_info_FeatureToPoin.MAX_Accessibility_rating'];
      var spaces = point.properties['off_street_FeatureToPoin.MAX_Parking_spaces'];

      // If rating is undefined, treat it as 'undefined'
      if (!rating) {
        rating = 'undefined';
      }

      if (rating in parkingSpacesByRating) {
        parkingSpacesByRating[rating] += spaces;
      }
    });

    // Determine the accessibility rating with the most parking spaces
    var maxRating = Object.keys(parkingSpacesByRating).reduce((a, b) => {
      return parkingSpacesByRating[a] > parkingSpacesByRating[b] ? a : b;
    });

    hex.properties.parkingSpaces = Object.values(parkingSpacesByRating).reduce((a, b) => a + b, 0);
    hex.properties.accessibilityRating = maxRating;
  }

  return hex;
}).filter(hex => hex.properties.parkingSpaces > 0);
      

      map.addSource('parking-data', {
        type: 'geojson',
        data: data
      });

      map.addSource('hexbin', {
        type: 'geojson',
        data: hexGrid
      });

      map.addLayer({
        id: 'hexbin-extrusion',
        type: 'fill-extrusion',
        source: 'hexbin',
        minzoom: 0,
        maxzoom: 14,
        paint: {
          'fill-extrusion-color': [
            'match',
            ['get', 'accessibilityRating'],
            '0', circleColors[0],
            '1', circleColors[1],
            '2', circleColors[2],
            '3', circleColors[3],
            '#d3d3d3'
          ],
          'fill-extrusion-height': [
            'step',
            ['get', 'parkingSpaces'],
            0,
            50, 100,
            100, 200,
            500, 400,
            1000, 600,
            2000, 800,
            3000, 1000,
            4000, 1200,
            5000, 1400,
            6000, 1600
          ],
          'fill-extrusion-opacity': 0.8,
          'fill-extrusion-base': 0
        }
      });

      map.addLayer({
        id: 'hexbin-outline',
        type: 'line',
        source: 'hexbin',
        minzoom: 14,
        maxzoom: 22,
        paint: {
          'line-color': 'white',
          'line-width': 1,
          'line-opacity': 0.1
        }
      });

// Object to keep track of visibility states by button ID
const visibilityStates = {
  'barbutton1': true,
  'barbutton2': true,
  'barbutton3': true,
  'barbutton4': true,
  'barbutton5': true,
  'barbutton6': true
};

document.querySelectorAll('.bar-button').forEach(button => {
  button.addEventListener('click', function() {
    const buttonId = this.id;
    const min = parseInt(this.getAttribute('data-min'), 10);
    const max = parseInt(this.getAttribute('data-max'), 10);
    
    // Toggle the button's active state
    if (this.classList.contains('active')) {
      // Turn off visibility for this range
      this.classList.remove('active');
      visibilityStates[buttonId] = false;
    } else {
      // Turn on visibility for this range
      this.classList.add('active');
      visibilityStates[buttonId] = true;
    }
    
    // Apply the combined filter
    applyFilters();
  });
});

function applyFilters() {
  const filters = ['any'];
  
  // Add filters for all visible ranges
  Object.keys(visibilityStates).forEach(buttonId => {
    if (visibilityStates[buttonId]) {
      const min = parseInt(document.getElementById(buttonId).getAttribute('data-min'), 10);
      const max = parseInt(document.getElementById(buttonId).getAttribute('data-max'), 10);
      filters.push([
        'all',
        ['>=', ['get', 'parkingSpaces'], min],
        ['<=', ['get', 'parkingSpaces'], max]
      ]);
    }
  });
  
  // If no filters are active, show all hexbins
  if (filters.length === 1) {
    map.setFilter('hexbin-extrusion', null);
  } else {
    map.setFilter('hexbin-extrusion', filters);
  }
}

// Initialize all buttons as active and apply initial filters
document.querySelectorAll('.bar-button').forEach(button => {
  button.classList.add('active');
});

        
      map.on('click', 'hexbin-extrusion', function(e) {
        var features = e.features;
        if (!features || features.length === 0) {
          return;
        }

        var feature = features[0];
        var properties = feature.properties;
        console.log('Feature Properties:', properties);

        var parkingSpaces = properties.parkingSpaces;
        var accessibilityRating = properties.accessibilityRating;
        var buildingCount = turf.pointsWithinPolygon(data, feature.geometry).features.length;
        var popupContent =
          'Average Accessibility Rating: ' + accessibilityRating + '<br>' +
          'Total Off-Street Parking Spaces: ' + parkingSpaces + '<br>' +
          'Building Count: ' + buildingCount;

        new mapboxgl.Popup()
          .setLngLat(e.lngLat)
          .setHTML(popupContent)
          .addTo(map);

        e.stopPropagation();
      });

      map.on('mouseenter', 'hexbin-extrusion', function() {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'hexbin-extrusion', function() {
        map.getCanvas().style.cursor = '';
      });

      map.addSource('building-points-source', {
        type: 'geojson',
        data: 'https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/off_street_final.geojson'
      });

      map.addLayer({
        id: 'building-points',
        type: 'circle',
        source: 'building-points-source',
        minzoom: 14,
        maxzoom: 22,
        paint: {
          'circle-color': [
            'match',
            ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'],
            accessNames[0], circleColors[0],
            accessNames[1], circleColors[1],
            accessNames[2], circleColors[2],
            accessNames[3], circleColors[3],
            '#d3d3d3'
          ],
          'circle-radius': [
            'interpolate',
            ['linear'],
            ['zoom'],
            14, 3,
            22, 10,
          ],
          'circle-pitch-alignment': 'map'
        },
        layout: {
          'visibility': 'visible'
        }
      });

      map.on('click', 'building-points', function(e) {
        var features = e.features;
        if (!features || features.length === 0) {
          return;
        }

        var feature = features[0];
        var properties = feature.properties;
        console.log('Feature Properties:', properties);

        var parkingSpaces = properties['off_street_FeatureToPoin.MAX_Parking_spaces'];
        var accessibilityRating = properties['buildings_info_FeatureToPoin.MAX_Accessibility_rating'];
        var buildingType = properties['off_street_FeatureToPoin.LAST_Parking_type'];
        var popupContent =
          'Parking Type: ' + buildingType + '<br>' +
          'Accessibility Rating: ' + accessibilityRating + '<br>' +
          'Off-Street Parking Spaces: ' + parkingSpaces;

        new mapboxgl.Popup()
          .setLngLat(e.lngLat)
          .setHTML(popupContent)
          .addTo(map);

        e.stopPropagation();
      });


      map.on('click', function(e) {
  // clears previous highlighted points
  clearPreviousHighlights();

  // this checks if the click is on a building point or hexbin, to not have 2 popups happen when clicking a hexbin or building points
  var featuresBuilding = map.queryRenderedFeatures(e.point, {
    layers: ['building-points']
  });
  var featuresHexbin = map.queryRenderedFeatures(e.point, {
    layers: ['hexbin-extrusion']
  });

  // for the nearest point highlight calculations
  // For the nearest point highlight calculations
var nearestTaxiRank = findNearestFeature(e.lngLat, taxiRanksData);
var nearestBusStop = findNearestFeature(e.lngLat, busStopsData);
var nearestTrainStation = findNearestFeature(e.lngLat, trainStationsData);
var nearestTramStops = findNearestFeature(e.lngLat, tramStopsData);

var nearestBuildingPoint = null;
if (featuresBuilding.length) {
    nearestBuildingPoint = featuresBuilding[0];
}

// Clear previous highlights and add new highlights
clearPreviousHighlights();
if (nearestTaxiRank) {
    highlightNearestPoint(nearestTaxiRank, '#FFDF75'); // yellow for taxi ranks
}
if (nearestBusStop) {
    highlightNearestPoint(nearestBusStop, '#F3819A'); // pink for bus stops
}
if (nearestTrainStation) {
    highlightNearestPoint(nearestTrainStation, '#f2a85a'); // green for train stations
}
if (nearestTramStops) {
    highlightNearestPoint(nearestTramStops, '#90A35C'); // orange for tram stops
}
});


      // cursor change
      map.on('mouseenter', 'building-points', function() {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'building-points', function() {
        map.getCanvas().style.cursor = '';
      });

      // adding the taxi ranks layer (default is off)
      map.addSource('taxi-ranks', {
        type: 'geojson',
        data: 'https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/taxi-ranks.geojson'
      });

      map.addLayer({
        id: 'taxi-ranks',
        type: 'circle',
        source: 'taxi-ranks',
        paint: {
          'circle-color': '#FFDF75', // yellow color for taxi ranks
           'circle-radius': [
            'interpolate',
            ['linear'],
            ['zoom'],
            14, 4,
            22, 12,
        ],
        'circle-stroke-width': 1, // add a 1px outline
        'circle-stroke-color': '#000000', // black outline
        'circle-pitch-alignment': 'map' // aligns the circles flat on the map
    },
    layout: {
        'visibility': 'none' // start with the layer hidden
    }
});


 // adding the tram stops layer (default is off)
      map.addSource('tram-stops', {
        type: 'geojson',
        data: 'https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/PTV_METRO_TRAM_FeaturesToJSO.geojson'
      });

      map.addLayer({
        id: 'tram-stops',
        type: 'circle',
        source: 'tram-stops',
        paint: {
          'circle-color': '#90A35C',
           'circle-radius': [
            'interpolate',
            ['linear'],
            ['zoom'],
            14, 4,
            22, 12,
        ],
        'circle-stroke-width': 1, // add a 1px outline
        'circle-stroke-color': '#000000', // black outline
        'circle-pitch-alignment': 'map' // aligns the circles flat on the map
    },
    layout: {
        'visibility': 'none' // start with the layer hidden
    }
});


      // add train stations layer (default is off)
      map.addSource('train-stations', {
        type: 'geojson',
        data: 'https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/metro-train-stations-with-accessibility-information.geojson'
      });

     map.addLayer({
    id: 'train-stations',
    type: 'circle',
    source: 'train-stations',
    paint: {
        'circle-color': '#f2a85a', // green color for train stations
        'circle-radius': [
            'interpolate',
            ['linear'],
            ['zoom'],
            14, 4,
            22, 12,
        ],
        'circle-stroke-width': 1, // add a 1px outline
        'circle-stroke-color': '#000000', // black outline
        'circle-pitch-alignment': 'map' // aligns the circles flat on the map
    },
    layout: {
        'visibility': 'none' // start with the layer hidden
    }
});


      // adding bus stops layer (default is off)
      map.addSource('bus-stops', {
        type: 'geojson',
        data: 'https://raw.githubusercontent.com/pennyip/OffStreet_Parking_melb/main/bus-stops.geojson'
      });

      map.addLayer({
        id: 'bus-stops',
        type: 'circle',
        source: 'bus-stops',
        paint: {
          'circle-color': '#F3819A', //
           'circle-radius': [
            'interpolate',
            ['linear'],
            ['zoom'],
            14, 4,
            22, 12,
        ],
        'circle-stroke-width': 1, // add a 1px outline
        'circle-stroke-color': '#000000', // black outline
        'circle-pitch-alignment': 'map' // aligns the circles flat on the map
    },
    layout: {
        'visibility': 'none' // start with the layer hidden
    }
});



      // this function will toggle the legend buttons on and off based on the accessibility rating which was defined earlier.
      // Filter functions for accessibility rating
function filterByAccessibilityRating(rating) {
  if (rating === 'undefined') {
    // Filter hexbins for ratings not in '0', '1', '2', or '3'
    map.setFilter('hexbin-extrusion', ['!in', ['get', 'accessibilityRating'], '0', '1', '2', '3']);

    // Filter building points for null values (considered 'undefined')
    map.setFilter('building-points', [
      'any',
      ['==', ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'], null],
      ['!in', ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'], '0', '1', '2', '3']
    ]);
  } else {
    // Filter for specific ratings
    map.setFilter('hexbin-extrusion', ['==', ['get', 'accessibilityRating'], rating]);
    map.setFilter('building-points', ['==', ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'], rating]);
  }
}

// Array to keep track of active accessibility ratings
let activeAccessibilityRatings = ['undefined', '0', '1', '2', '3'];

// Function to update filters based on active ratings
function updateFilters() {
  if (activeAccessibilityRatings.length === 0) {
    // If no ratings are active, hide all hexbins and building points
    map.setFilter('hexbin-extrusion', ['==', ['get', 'accessibilityRating'], 'none']);
    map.setFilter('building-points', ['==', ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'], 'none']);
  } else {
    map.setFilter('hexbin-extrusion', [
      'in',
      ['get', 'accessibilityRating'],
      ['literal', activeAccessibilityRatings]
    ]);

    // Include null values for 'ratingnone'
    if (activeAccessibilityRatings.includes('undefined')) {
      map.setFilter('building-points', [
        'any',
        ['in', ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'], ['literal', activeAccessibilityRatings]],
        ['==', ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'], null]
      ]);
    } else {
      map.setFilter('building-points', [
        'in',
        ['get', 'buildings_info_FeatureToPoin.MAX_Accessibility_rating'],
        ['literal', activeAccessibilityRatings]
      ]);
    }
  }
  updateButtonStates();
}

// Function to toggle a rating filter
function toggleAccessibilityRating(rating) {
  const index = activeAccessibilityRatings.indexOf(rating);
  if (index > -1) {
    // Rating is active, so remove it
    activeAccessibilityRatings.splice(index, 1);
  } else {
    // Rating is not active, so add it
    activeAccessibilityRatings.push(rating);
  }
  updateFilters();
}

// Function to update button states based on active ratings
function updateButtonStates() {
  ['ratingnone', 'rating0', 'rating1', 'rating2', 'rating3'].forEach(function(id) {
    const button = document.getElementById(id);
    if (id === 'ratingnone') {
      // 'ratingnone' should be active if 'undefined' is in the array
      if (activeAccessibilityRatings.includes('undefined')) {
        button.classList.add('active');
      } else {
        button.classList.remove('active');
      }
    } else {
      // Handle other ratings
      if (activeAccessibilityRatings.includes(id.replace('rating', ''))) {
        button.classList.add('active');
      } else {
        button.classList.remove('active');
      }
    }
  });
}

// Add event listeners to buttons
document.getElementById('ratingnone').addEventListener('click', function() {
  toggleAccessibilityRating('undefined');
});

document.getElementById('rating0').addEventListener('click', function() {
  toggleAccessibilityRating('0');
});

document.getElementById('rating1').addEventListener('click', function() {
  toggleAccessibilityRating('1');
});

document.getElementById('rating2').addEventListener('click', function() {
  toggleAccessibilityRating('2');
});

document.getElementById('rating3').addEventListener('click', function() {
  toggleAccessibilityRating('3');
});

// Initialize all buttons as active, including 'undefined'
activeAccessibilityRatings = ['undefined', '0', '1', '2', '3'];
document.querySelectorAll('.legend-button').forEach(button => {
  button.classList.add('active'); // Ensure buttons are initialized as active
});
updateFilters();



      updateFiltersAndVisibility();
    });
    


    // for the taxi ranks button
    document.getElementById('taxi-ranks').addEventListener('click', function() {
      var visibility = map.getLayoutProperty('taxi-ranks', 'visibility');
      map.setLayoutProperty('taxi-ranks', 'visibility', visibility === 'visible' ? 'none' : 'visible');

      // toggle button colour. This will change the colours when activated to match the point colours
      var button = document.getElementById('taxi-ranks');
      if (visibility === 'visible') {
        button.style.backgroundColor = ''; // reset to default colour
      } else {
        button.style.backgroundColor = '#FFDF75'; // set to point colour
      }
    });

 // for the tram stops button
    document.getElementById('tram-stops').addEventListener('click', function() {
      var visibility = map.getLayoutProperty('tram-stops', 'visibility');
      map.setLayoutProperty('tram-stops', 'visibility', visibility === 'visible' ? 'none' : 'visible');

      // toggle button colour. This will change the colours when activated to match the point colours
      var button = document.getElementById('tram-stops');
      if (visibility === 'visible') {
        button.style.backgroundColor = ''; // reset to default colour
      } else {
        button.style.backgroundColor = '#90A35C'; // set to point colour
      }
    });

    // for the train stations button
    document.getElementById('train-stations').addEventListener('click', function() {
      var visibility = map.getLayoutProperty('train-stations', 'visibility');
      map.setLayoutProperty('train-stations', 'visibility', visibility === 'visible' ? 'none' : 'visible');
      var button = document.getElementById('train-stations');
      if (visibility === 'visible') {
        button.style.backgroundColor = ''; // reset to default colour
      } else {
        button.style.backgroundColor = '#f2a85a'; // set to point colour
      }
    });

    // for the bus stops button
    document.getElementById('bus-stops').addEventListener('click', function() {
      var visibility = map.getLayoutProperty('bus-stops', 'visibility');
      map.setLayoutProperty('bus-stops', 'visibility', visibility === 'visible' ? 'none' : 'visible');

      // toggle button colour for bus stops
      var button = document.getElementById('bus-stops');
      if (visibility === 'visible') {
        button.style.backgroundColor = ''; // reset to default colour
      } else {
        button.style.backgroundColor = '#F3819A'; // set to point colour
      }
    });


    //control button
    map.addControl(new mapboxgl.NavigationControl(), 'top-left');
  });


// Function to find the nearest feature and calculate distance
function findNearestFeature(clickedPoint, geojsonData) {
  if (!geojsonData) return null;

  var nearestDistance = Infinity;
  var nearestFeature = null;
  geojsonData.features.forEach(function(feature) {
    var distance = turf.distance(
      turf.point(clickedPoint.toArray()),
      turf.point(feature.geometry.coordinates)
    );
    if (distance < nearestDistance) {
      nearestDistance = distance;
      nearestFeature = feature;
    }
  });
  if (nearestFeature) {
    nearestFeature.properties.distance = nearestDistance * 1000; // Convert distance to meters
  }
  return nearestFeature;
}

async function highlightNearestPoint(feature, color) {
    // Generate a unique ID for the highlight
    var id = 'highlight-' + Math.random().toString(36).substr(2, 9);

    // Determine the text based on the feature type
    var text = '';

    // Handle tram stops
    if (feature.properties.STOP_NAME) {
        text = `Tram Stop: ${feature.properties.STOP_NAME.trim()}`;
    } 
    // Handle train stations
    else if (feature.properties.station) {
        text = `${feature.properties.station.trim()} Station`;
    } 
    // Handle taxi ranks
    else if (feature.properties.loc_desc) {
        text = `Taxi Rank: ${feature.properties.loc_desc.trim()}`;
    } 
    // Handle bus stops
    else if (feature.properties.address) {
        text = `Bus Stop: ${feature.properties.address.trim()}`;
    } 
    else if (feature.geometry.type === 'Point' && !feature.properties.address) {
        // Fallback for bus stops if address is not pre-existing in properties
        const coordinates = feature.geometry.coordinates;
        try {
            const address = await getAddress(coordinates);
            text = `Bus Stop: ${address.trim()}`;
        } catch (error) {
            console.error('Error retrieving address:', error);
            text = 'Bus Stop';
        }
    } 
    // Default case
    else {
        text = 'Feature';
    }

    // Append distance in meters if available
    if (feature.properties.distance !== undefined) {
        text += `\nDistance: ${Math.round(feature.properties.distance)} meters`;
    }

  // Add the circle layer for highlighting
  map.addLayer({
    id: id,
    type: 'circle',
    source: {
      type: 'geojson',
      data: feature
    },
    paint: {
      'circle-color': color,
      'circle-stroke-color': 'black',
      'circle-stroke-opacity': 0.5,
      'circle-radius': [
        'interpolate',
        ['linear'],
        ['zoom'],
        14, 6,
        22, 14
      ],
      'circle-pitch-alignment': 'map'
    }
  });


  // Add the symbol layer for the text
  var textId = id + '-text';
  map.addLayer({
    id: textId,
    type: 'symbol',
    source: {
      type: 'geojson',
      data: feature
    },
    layout: {
      'text-field': text,  // Display the appropriate text with distance
      'text-size': 10,
      'text-offset': [0, 3], // Position the text above the circle
    },
    paint: {
      'text-color': 'white', // Set the text color
    }
  });

  // Remove both layers when the highlight needs to disappear
  setTimeout(function() {
    map.removeLayer(id);
    map.removeLayer(textId);
  }, 5000); // Adjust the timeout as needed
}

// Clear previous highlights
function clearPreviousHighlights() {
  highlightedLayers.forEach(function(id) {
    if (map.getLayer(id)) {
      map.removeLayer(id);
    }
  });
  highlightedLayers = [];
}

//for the sidebar button to toggle expand and collapse it
document.getElementById('toggle-sidebar').addEventListener('click', function() {
  var sidebar = document.getElementById('sidebar');
  sidebar.classList.toggle('collapsed');
  this.classList.toggle('collapsed');
});


// required for the highlight building points and public transport points
var highlightedLayers = [];

// Toggle button for 2D/3D view
const toggleButton = document.getElementById('toggle-2d-3d');

// Function to update button text based on view mode
function updateButtonText() {
  const is3D = map.getPitch() > 0;
  toggleButton.textContent = is3D ? '3D' : '2D';
}

// Initialize button text based on the initial view mode
updateButtonText();

// Event listener for the toggle button
toggleButton.addEventListener('click', () => {
  const is3D = map.getPitch() > 0;
  if (is3D) {
    // Switch to 2D view
    map.easeTo({
      pitch: 0,
      bearing: 0,
      duration: 500
    });
  } else {
    // Switch to 3D view
    map.easeTo({
      pitch: 60, // Adjust pitch for 3D effect
      bearing: 30, // Adjust bearing for 3D effect
      duration: 500
    });
  }
  // Update button text after switching views
  updateButtonText();
});


let currentPopup = null;
let popupTimeout = null;

// Mapbox Geocoding API token
const mapboxToken = 'pk.eyJ1IjoiczQwMTY2OTgiLCJhIjoiY2x0b3lyMDcyMGtzcTJrcGFlN3ZzNnRtZyJ9.oc1p4S7lER0OXK8G6q1w8Q'; // Replace with your Mapbox API token

// Function to create a popup
function createPopup(coordinates, html) {
    // Clear the existing popup if there is one
    if (currentPopup) {
        currentPopup.remove();
        clearTimeout(popupTimeout);
    }

    // Create a new popup
    currentPopup = new mapboxgl.Popup()
        .setLngLat(coordinates)
        .setHTML(html)
        .addTo(map);

    // Set a timeout to automatically remove the popup after 8 seconds
    popupTimeout = setTimeout(() => {
        if (currentPopup) {
            currentPopup.remove();
            currentPopup = null;
        }
    }, 8000);
}

// Function to get address using Mapbox Geocoding API
async function getAddress(coordinates) {
    const [lng, lat] = coordinates;
    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?access_token=${mapboxToken}`;

    try {
        const response = await fetch(url);
        const data = await response.json();
        const address = data.features[0]?.place_name || 'Address not found';
        return address;
    } catch (error) {
        console.error('Error fetching address:', error);
        return 'Address not available';
    }
}

// Add hover interactions for train stations
map.on('mouseenter', 'train-stations', (e) => {
    map.getCanvas().style.cursor = 'pointer';
    const coordinates = e.features[0].geometry.coordinates.slice();
    const description = e.features[0].properties.station;
    createPopup(coordinates, `<strong>Train Station:</strong> ${description}`);
});

map.on('mouseleave', 'train-stations', () => {
    map.getCanvas().style.cursor = '';
    if (currentPopup) {
        currentPopup.remove();
    }
});

// Add hover interactions for taxi ranks
map.on('mouseenter', 'taxi-ranks', (e) => {
    map.getCanvas().style.cursor = 'pointer';
    const coordinates = e.features[0].geometry.coordinates.slice();
    const description = e.features[0].properties.loc_desc;
    createPopup(coordinates, `<strong>Taxi Rank Location:</strong> ${description}`);
});

map.on('mouseleave', 'taxi-ranks', () => {
    map.getCanvas().style.cursor = '';
    if (currentPopup) {
        currentPopup.remove();
    }
});

// Add hover interactions for tram stops
map.on('mouseenter', 'tram-stops', (e) => {
    map.getCanvas().style.cursor = 'pointer';
    const coordinates = e.features[0].geometry.coordinates.slice();
    const description = e.features[0].properties.STOP_NAME;
    createPopup(coordinates, `<strong>Tram Stop:</strong> ${description}`);
});

map.on('mouseleave', 'tram-stops', () => {
    map.getCanvas().style.cursor = '';
    if (currentPopup) {
        currentPopup.remove();
    }
});

// Add hover interactions for bus stops
map.on('mouseenter', 'bus-stops', async (e) => {
    map.getCanvas().style.cursor = 'pointer';
    const coordinates = e.features[0].geometry.coordinates.slice();
    const address = await getAddress(coordinates);
    createPopup(coordinates, `<strong>Bus Stop Address:</strong> ${address}`);
});

map.on('mouseleave', 'bus-stops', () => {
    map.getCanvas().style.cursor = '';
    if (currentPopup) {
        currentPopup.remove();
    }
});
    
</script>
</body>
</html>
